% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/seagull.R
\name{with_flock}
\alias{with_flock}
\alias{with_flock_}
\title{Evaluate expression with file lock}
\usage{
with_flock(filename, expr, envir = parent.frame(), delay = 0.01,
  max_delay = 0.1, timeout = Inf, error = TRUE, verbose = FALSE)

with_flock_(filename, expr, envir = parent.frame(), delay = 0.01,
  max_delay = 0.1, timeout = Inf, error = TRUE, verbose = FALSE)
}
\arguments{
\item{filename}{The name of the lockfile.  If \code{NULL}, no
lockfile is used and the action always runs.}

\item{expr}{Expression to evaluate once the lock is acquired.
This expression must not affect the file \code{filename} in any
way (see warnings in the package README).}

\item{envir}{Environment in which to evaluate \code{expr}.  The
default is usually reasonable.}

\item{delay}{Initial period to poll the file for release if it is
locked.  Note this is a \emph{minimum} time to delay.  On POSIX
system with \code{fcntl} I see delays around the 0.2s mark when
accessing files over SMB so small values there are likely
aspirational.  This time is also \emph{additional} to the
\code{fcntl} call (i.e., the pattern is try to lock, then sleep).}

\item{max_delay}{Maximum period between polls; the delay will grow
from \code{delay} to \code{max_delay} over subsequent calls.}

\item{timeout}{Total maximum time to wait.  If a lock cannot be
acquired in this period, we either error or return without
evaluating \code{expr} (see Details).}

\item{error}{Is failure to acquire a lock an error?  If
\code{TRUE} then an error is thrown or the value if \code{expr}
is returned.  If \code{FALSE} the return value is a list with
the first element indicating success or not and the second
element being either a condition or the return value.  See
Details.}

\item{verbose}{Print information as at each lock acquisition
attempt.  May be useful in debugging.}
}
\description{
Evaluate an expression after acquiring, and while holding, a file
lock.  The \code{with_flock_} version uses standard evaluation and
is suitable for programming.
}
\details{
The behaviour on error is controlled by the \code{error} argument.
If \code{TRUE} (the default) then if a lock cannot be established
then \code{with_flock} will throw an error and not return.  If
there is no error the return value is whatever \code{expr}
evaluates to.  (If \code{expr} itself throws an error the lock
will always be cleaned up, though this may fail if the lockfile is
removed by the code in \code{expr} or another process -- try to
avoid this!)

If \code{error=FALSE} the return value is always a list of length
2.  The first element is a logical scalar \code{TRUE} or
\code{FALSE} indicating if the lock was acquired and the
expression evaluated.  The second element is the value of
\code{expr} if the lock was acquired or a condition object
describing why the lock was not acquired.  If \code{expr} throws
an error, that error will still not be caught (use
\code{tryCatch}).

In either case, if a lock cannot be established the code in
\code{expr} is not evaluated.
}
\section{Warning}{


It is not safe to use the file for anything, including locking it
  a second time (e.g. \code{with_flock(filename,
  with_flock(filename, ...))}).  Simply opening or closing a
  handle to a file will break the lock on non-Windows systems
  (this is a limitation of the underlying system calls).
}
\examples{
## Demonstrating this is difficult because for a lock to fail
## another process needs to hold a lock on the file.  But the
## basic approach for using it is below.

## First, we have a file that we want to modify; say path:
path <- tempfile()
writeLines(c("a", "b", "c"), path)

## Then we have another file that we'll use as a lock.  We can't
## safely write to this file (see notes above) so it's simplest to
## have a separate file here.
lock <- paste0(path, ".lock")

## Suppose we want to take the first element of the data in 'path'.
## This involves a read and a write operation so is not atomic -
## another process could read the file in the meantime and we'd
## both pull the same element out.  But if we advertise that we're
## using it by using a lock the other process can wait until we
## release the lock:
res <- with_flock(lock, {
  txt <- readLines(path)
  writeLines(txt[-1], path)
  txt[[1]]
})
res
}

