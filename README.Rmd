```{r, setup, echo = FALSE, message = FALSE}
knitr::opts_chunk$set(
  comment = "#>",
  tidy = FALSE,
  error = FALSE,
  fig.width = 8,
  fig.height = 8)
```

# seagull

[![Linux Build Status](https://travis-ci.org/richfitz/seagull.svg?branch=master)](https://travis-ci.org/richfitz/seagull)
[![Windows Build status](https://ci.appveyor.com/api/projects/status/github/richfitz/seagull?svg=true)](https://ci.appveyor.com/project/richfitz/seagull)

File locking for R.

## Installation

```{r eval = FALSE}
devtools::install_github("richfitz/seagull")
```

## Usage

```{r}
library(seagull)
```

## Design condsiderations

**This package does not use R's connection objects**.  A sane native implementation of file locking would use the result of `file(...)`, but because of the way R's connection objects are implemented this is not possible (the actual file descriptor object is stored in the private data of the connection object and the format of that is non-API).

Unfortunately with the [implementation of unix file locking](http://0pointer.de/blog/projects/locking.html) the lock will be broken if _any_ connection to the object is closed.  So it is in general unsafe to open a second connection to the file object.  A possibly safe pattern would be:

1. Acquire lock
2. Open a second connection to the file
3. Write whatever you need to write
4. Close the file
5. Immediately close the lock

The lock will be lost at step 4 above but that should not matter as `seagull` never writes to the files it holds.  Note that this situation applies to things like `writeLines`, `write.csv`, etc; those functions encompass steps 2-4 in the above.

Future versions may implement the full connection interface to allow passing the locked file around as an R connection.

## License

MIT + file LICENSE Â© [Rich FitzJohn](https://github.com/richfitz).
